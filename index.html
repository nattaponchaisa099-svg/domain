<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DOMAIN EXPANSION</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
}
video {
  position: absolute;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
canvas {
  position: absolute;
  width: 100%;
  height: 100%;
}
#text {
  position: absolute;
  bottom: 20%;
  width: 100%;
  text-align: center;
  font-size: 30px;
  color: cyan;
  font-weight: bold;
  text-shadow: 0 0 20px cyan;
  display: none;
}
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="text">DOMAIN EXPANSION</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const text = document.getElementById('text');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

navigator.mediaDevices.getUserMedia({ video: true })
.then(stream => {
  video.srcObject = stream;
})
.catch(err => {
  alert("Camera error");
});

const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(results => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (results.multiHandLandmarks.length > 0) {
    text.style.display = "block";

    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, 150, 0, 2*Math.PI);
    ctx.strokeStyle = "cyan";
    ctx.lineWidth = 5;
    ctx.stroke();
  } else {
    text.style.display = "none";
  }
});

const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({image: video});
  },
  width: 640,
  height: 480
});
camera.start();
</script>

</body>
</html>}
</style>
</head>

<body>

<video class="input_video" style="display:none"></video>
<canvas class="output_canvas"></canvas>
<div id="domainText">DOMAIN EXPANSION</div>

<script>
const videoElement = document.querySelector('.input_video');
const canvasElement = document.querySelector('.output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const text = document.getElementById("domainText");

canvasElement.width = window.innerWidth;
canvasElement.height = window.innerHeight;

let rotation = 0;

const hands = new Hands({
  locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
  }
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(results => {

  canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);
  canvasCtx.drawImage(results.image,0,0,canvasElement.width,canvasElement.height);

  if(results.multiHandLandmarks.length > 0){

    const landmarks = results.multiHandLandmarks[0];

    let openFingers = 0;
    const tips = [8,12,16,20];
    const pips = [6,10,14,18];

    for(let i=0;i<tips.length;i++){
      if(landmarks[tips[i]].y < landmarks[pips[i]].y){
        openFingers++;
      }
    }

    if(openFingers >= 4){

      text.style.display = "block";

      // ทำฉากมืดลง
      canvasCtx.fillStyle = "rgba(0,0,0,0.5)";
      canvasCtx.fillRect(0,0,canvasElement.width,canvasElement.height);

      // วาดวงเวทย์หมุน
      const x = canvasElement.width/2;
      const y = canvasElement.height/2;
      const radius = 200;

      canvasCtx.save();
      canvasCtx.translate(x,y);
      canvasCtx.rotate(rotation);
      canvasCtx.beginPath();
      canvasCtx.arc(0,0,radius,0,Math.PI*2);
      canvasCtx.strokeStyle = "#ff00ff";
      canvasCtx.lineWidth = 5;
      canvasCtx.shadowColor = "#ff00ff";
      canvasCtx.shadowBlur = 30;
      canvasCtx.stroke();
      canvasCtx.restore();

      rotation += 0.05;

      // ออร่าเรืองแสง
      canvasCtx.beginPath();
      canvasCtx.arc(x,y,250,0,Math.PI*2);
      canvasCtx.fillStyle = "rgba(170,0,255,0.2)";
      canvasCtx.fill();

    } else {
      text.style.display = "none";
    }
  } else {
    text.style.display = "none";
  }
});

const camera = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width:1280,
  height:720
});
camera.start();
</script>

</body>
</html>
